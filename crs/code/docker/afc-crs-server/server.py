# generated by fastapi-codegen:
#   filename:  converted_openapi3_crs_server.json
#   timestamp: 2025-03-04T20:21:20+00:00

from __future__ import annotations
from http.client import HTTPException
from typing import Annotated, Optional, List, Dict
import os
import secrets
from uuid import UUID

import uvicorn
import subprocess
import json
# Additions from example-crs-architecture/docs/telemetry
import trace
import logging

from fastapi import Depends, FastAPI, HTTPException, status, BackgroundTasks
# Additions from example-crs-webservice/my_crs/task_server/server.py
from fastapi.responses import JSONResponse
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from urllib3.exceptions import MaxRetryError, NewConnectionError

# imports for telemetry. TODO implement telemetry
from openai import OpenAI
from opentelemetry import trace
import openlit

# imports from openapi generated client
from openapi_client.api.pov_api import PovApi, TypesPOVSubmissionResponse
from openapi_client.api.ping_api import PingApi, TypesPingResponse
from openapi_client.api.patch_api import PatchApi
from openapi_client.api.bundle_api import BundleApi
from openapi_client.models.types_bundle_submission import TypesBundleSubmission
from openapi_client.models.types_bundle_submission_response import TypesBundleSubmissionResponse
from openapi_client.models.types_patch_submission import TypesPatchSubmission
from openapi_client.models.types_patch_submission_response import TypesPatchSubmissionResponse
from openapi_client.models.types_pov_submission import TypesPOVSubmission
from openapi_client.models.types_architecture import TypesArchitecture
from openapi_client.models.types_submission_status import TypesSubmissionStatus
from openapi_client.api_client import ApiClient
from openapi_client.configuration import Configuration
from models.types import (
    SARIFBroadcast,
    SARIFBroadcastDetail,
    Status,
    StatusState,
    StatusTasksState,
    Task,
    TaskDetail,
)

app = FastAPI(
    title='afc-crs-server',
    contact={},
    version='1.4.0',
    servers=[{'url': '/'}],
)

# configure logger
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Find python adapter handoff-to-lax.py
lacrosse_path_env_var = os.environ.get("DOCKER_LACROSSE_HOME")
print(f"DOCKER_LACROSSE_HOME is {lacrosse_path_env_var}")
handoff_to_lax = os.path.join(lacrosse_path_env_var, "code", "tools", "api", "handoff-to-lax.py")
print(f"handoff to lax tool path is : {handoff_to_lax}")

# Getting release tag
lacrosse_release_tag = os.environ.get("CRS_LAX_RELEASE_TAG")

# The exposed endpoints must be authenticated using HTTP Basic.
# Credentials will be composed of an API key and token which will be used as the username
# and password in HTTP Basic Auth.
# API keys will be UUIds, tokens will be random alphanumeric strings of at least 32 chars.
# Tokens should be stored using Argon2ID.
security = HTTPBasic()

def get_environment_var(var: str) -> str:
    logging.info(f"Checking if environemnt variable {var} is set.")
    if (var in os.environ):
        return os.environ[var]
    else:
        logging.error(f"Environment variable unset: \"{var}\"")
        exit(1)

COMPETITION_API_TEAM_ID = get_environment_var("COMPETITION_API_TEAM_ID")
COMPETITION_API_TEAM_SECRET = get_environment_var("COMPETITION_API_TEAM_SECRET")
COMPETITION_API_ENDPOINT = get_environment_var("COMPETITION_API_ENDPOINT")

CRS_API_KEY_ID = get_environment_var("CRS_API_KEY_ID").encode("utf-8")
CRS_API_KEY_TOKEN = get_environment_var("CRS_API_KEY_TOKEN").encode("utf-8")

def check_auth(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
    """
    Reference: https://fastapi.tiangolo.com/advanced/security/http-basic-auth/
    """
    logging.info("Checking HTTP Basic Credentials.")
    current_username_bytes = credentials.username.encode("utf8")
    correct_username_bytes = CRS_API_KEY_ID

    logging.info(f"current_username: {current_username_bytes}")
    logging.info(f"correct_username: {correct_username_bytes}")

    is_correct_username = secrets.compare_digest(
        current_username_bytes, correct_username_bytes
    )

    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = (CRS_API_KEY_TOKEN)  # FIXME: Use hashed password

    logging.info(f"current_password: {current_password_bytes}")
    logging.info(f"correct_password: {correct_password_bytes}")

    is_correct_password = secrets.compare_digest(
        current_password_bytes, correct_password_bytes
    )

    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )

    logging.info(f"check_auth returning: {credentials.username}")
    return credentials.username

@app.get('/status/', response_model=Status, tags=['status'])
def get_status_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)]
) -> Status:
    """
    CRS Status
    """
    logging.info("API Status endpoint: status endpoint get_status prompted.")
    def is_competition_api_ready():
        logging.info("API Status endpoint: checking for competition api ready.")
        is_ready = False
        configuration = Configuration(
            host=COMPETITION_API_ENDPOINT,
            username=COMPETITION_API_TEAM_ID,
            password=COMPETITION_API_TEAM_SECRET,
        )

        api_client = ApiClient(
            configuration=configuration,
            header_name="ContentType",
            header_value="application/json",
        )

        api = PingApi(api_client=api_client)

        response = None
        try:
            response: TypesPingResponse = api.v1_ping_get()
        except (MaxRetryError, NewConnectionError) as e:
            is_ready = False

        if isinstance(response, TypesPingResponse):
            if response.status:
                is_ready = True

        return is_ready

    ready: bool = is_competition_api_ready()
    logging.info(f"API Status endpoint: is_competition_api_ready has returned: {ready}")

    details = {}
    tasks = StatusTasksState(
        canceled=0,
        errored=0,
        failed=0,
        pending=0,
        processing=0,
        succeeded=0,
        waiting=0,
    )
    state = StatusState(tasks=tasks)
    version = lacrosse_release_tag  # CHANGEME whenever a release is made.
    logging.info(f"API Status endpoint: API has crs version {version}")
    logging.info(f"API Status endpoint: Status responding with {Status(details=details, ready=ready, since=0, state=state, version=version)}...")
    return Status(
        details=details, ready=ready, since=0, state=state, version=version
    )

@app.delete('/status/', response_model=str, tags=['status'])
def delete_status_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)]
) -> str:
    """
    Reset status stats
    """
    logging.info("API Status endpoint: status endpoint delete_status prompted.")

    delete_status_return = "Time to delete status"
    logging.info(f"API Status endpoint: status endpoint delete_status returning: {delete_status_return}")

    return delete_status_return
    # pass

@app.post('/v1/sarif/', response_model=None, responses={'202': {'model': str}}, tags=['sarif'])
def post_v1_sarif_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: SARIFBroadcast
    ) -> str:
    """
    Submit Sarif Broadcast
    """
    logging.info("API Sarif endpoint: sarif endpoint post_v1_sarif prompted.")
    logging.info(f"Sarif Data is: {body}")
    broadcasts: List[SARIFBroadcastDetail] = body.broadcasts
    sarif_message_time = str(body.message_time)
    sarif_message_id = str(body.message_id)
    for broadcast in broadcasts:
        do_sarif(broadcast, sarif_message_id, sarif_message_time)
    # post_sarif_return = "super awesome sarif stuff"
    # logging.info(f"API Sarif endpoint: sarif endpoint returning: {post_sarif_return}")
    # return post_sarif_return
    pass

def do_sarif(broadcast: SARIFBroadcastDetail, sarif_message_id, sarif_message_time):
    logging.info(f"API Sarif endpoing: preparing to start sarif: {broadcast}")
    metadata_dict: dict = broadcast.metadata
    print(f"metadata_dict is {metadata_dict}")
    logging.info("API Sarif endpoint: running the handoff for the sarif.")
    sarif_payload = broadcast.json()
    print("sarif payload in do_sarif is...")
    print(f"{sarif_payload}")
    print("Dict broadcast . sarif in do_sarif is...")
    print(f"{broadcast.sarif}")
    try:
        subprocess.run(["python", handoff_to_lax, sarif_payload, sarif_message_id, sarif_message_time, "sarif_post"], check=True)
    except subprocess.CalledProcessError as err:
        logging.error("Handoff sarif to lisp err: {err}")


@app.post('/v1/task/', response_model=None, responses={'202': {'model': str}}, tags=['task'])
def post_v1_task_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: Task
    ) -> Optional[str]:
    """
    Submit Task for work i.e "receive task"
    """
    logging.info("API Task endpoint: task endpoint post_v1_task prompted.")
    logging.info(f"Task.raw_data: {body.raw_data}")
    tasks: List[TaskDetail] = body.tasks
    task_message_time = str(body.message_time)
    task_message_id = str(body.message_id)
    # logging.info(f"body.tasks is {body.tasks}")
    for task in tasks:
        do_task(task, task_message_id, task_message_time)
    # pass

def do_task(task: TaskDetail, task_message_id, task_message_time):
    logging.info(f"API Task endpoint: preparing to start task: {task}")

    metadata_dict: dict = task.metadata
    print(f"metadata_dict is {metadata_dict}")
    logging.info("API Task endpoint: passing the task to handoff for preparing CP_ROOT.")
    task_payload = task.json()
    try:
        subprocess.run(["python", handoff_to_lax, task_payload, task_message_id, task_message_time, "task_post"], check=True)
    except subprocess.CalledProcessError as err:
        logging.error("Handoff to lisp for preparing CP_ROOT err: {err}")
    # log_action("category", "name", metadata_dict, {})

@app.delete('/v1/task/', response_model=str, tags=['task'])
def delete_v1_task_(
    # credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)]
    ) -> str:
    """
    Cancel Tasks
    """
    logging.info("API Task endpoint: delete_v1_tasks prompted.")

    delete_tasks_return="goodbye tasks"

    logging.info(f"API Task endpoint: delete_v1_tasks returning: {delete_tasks_return}")
    return delete_tasks_return
    # pass


@app.delete('/v1/task/{task_id}/', response_model=str, tags=['task'])
def delete_v1_task_task_id_(
    # credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    task_id: UUID
    ) -> str:
    """
    Cancel Task
    """
    logging.info(f"API Task endpoint: delete_v1_task_{task_id} prompted.")

    delete_single_task_return="goodbye task {task_id}"
    logging.info(f"API Task endpoint: delete_v1_tasks returning: {delete_single_task_return}")
    return delete_single_task_return

    # pass

if __name__ == "__main__":
    uvicorn.run("server:app", host="0.0.0.0", port=8000, log_level="debug", reload=True)