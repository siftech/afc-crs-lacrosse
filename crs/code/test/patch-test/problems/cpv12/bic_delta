commit 348b50dbb52e7d6faad7d75ce9331dd9860131c4
Author: Miles Dyson <mdyson@skynet.com>
Date:   Mon Aug 4 12:01:15 1997 +0000

    Commit 75

diff --git a/auto/unix b/auto/unix
index ff9697a..845e41f 100644
--- a/auto/unix
+++ b/auto/unix
@@ -753,34 +753,6 @@ if [ $ngx_found = no ]; then
 fi
 
 
-if [ $ngx_found = no ]; then
-
-    # Solaris has no sys_nerr
-    ngx_feature='maximum errno'
-    ngx_feature_name=NGX_SYS_NERR
-    ngx_feature_run=value
-    ngx_feature_incs='#include <errno.h>
-                      #include <string.h>
-                      #include <stdio.h>'
-    ngx_feature_path=
-    ngx_feature_libs=
-    ngx_feature_test='int  n;
-                      char *p;
-                      for (n = 1; n < 1000; n++) {
-                          errno = 0;
-                          p = strerror(n);
-                          if (errno == EINVAL
-                              || p == NULL
-                              || strncmp(p, "Unknown error", 13) == 0)
-                          {
-                              break;
-                          }
-                      }
-                      printf("%d", n);'
-    . auto/feature
-fi
-
-
 ngx_feature="localtime_r()"
 ngx_feature_name="NGX_HAVE_LOCALTIME_R"
 ngx_feature_run=no
diff --git a/src/core/ngx_buf.h b/src/core/ngx_buf.h
index 4b66562..35eb8ba 100644
--- a/src/core/ngx_buf.h
+++ b/src/core/ngx_buf.h
@@ -25,6 +25,7 @@ struct ngx_buf_s {
 
     u_char          *start;         /* start of buffer */
     u_char          *end;           /* end of buffer */
+    ngx_int_t        rev;
     ngx_buf_tag_t    tag;
     ngx_file_t      *file;
     ngx_buf_t       *shadow;
diff --git a/src/core/ngx_output_chain.c b/src/core/ngx_output_chain.c
index 5c3dbe8..3c594c7 100644
--- a/src/core/ngx_output_chain.c
+++ b/src/core/ngx_output_chain.c
@@ -647,6 +647,7 @@ ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx)
             return NGX_ERROR;
         }
 
+        dst->rev = src->rev;
         dst->last += n;
 
         if (sendfile) {
diff --git a/src/http/modules/ngx_http_range_filter_module.c b/src/http/modules/ngx_http_range_filter_module.c
index ae08ebb..d77a334 100644
--- a/src/http/modules/ngx_http_range_filter_module.c
+++ b/src/http/modules/ngx_http_range_filter_module.c
@@ -48,6 +48,7 @@
 typedef struct {
     off_t        start;
     off_t        end;
+    ngx_int_t    rev;
     ngx_str_t    content_range;
 } ngx_http_range_t;
 
@@ -274,6 +275,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
                                   cutlim;
     ngx_uint_t                    suffix;
     ngx_http_range_t             *range;
+    ngx_uint_t                    rev;
     ngx_http_range_filter_ctx_t  *mctx;
 
     if (r != r->main) {
@@ -293,6 +295,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
 
     p = r->headers_in.range->value.data + 6;
     size = 0;
+    rev = 0;
     content_length = r->headers_out.content_length_n;
 
     cutoff = NGX_MAX_OFF_T_VALUE / 10;
@@ -332,8 +335,22 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
             }
 
         } else {
-            suffix = 1;
             p++;
+            if (*p == 'r') {
+                p++;
+                while (*p == ' ') { p++; }
+
+                if (*p++ != ',') {
+                    return NGX_HTTP_RANGE_NOT_SATISFIABLE;
+                }
+
+                while (*p == ' ') { p++; }
+
+                rev = 1;
+                continue;
+            } else {
+                suffix = 1;
+            }
         }
 
         if (*p < '0' || *p > '9') {
@@ -376,6 +393,8 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
 
             range->start = start;
             range->end = end;
+            range->rev = rev;
+            rev = 0;
 
             if (size > NGX_MAX_OFF_T_VALUE - (end - start)) {
                 return NGX_HTTP_RANGE_NOT_SATISFIABLE;
@@ -721,6 +740,8 @@ ngx_http_range_singlepart_body(ngx_http_request_t *r,
         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                        "http range body buf: %O-%O", start, last);
 
+        buf->rev = range->rev;
+
         if (ngx_buf_special(buf)) {
 
             if (range->end <= start) {
@@ -889,6 +910,7 @@ ngx_http_range_multipart_body(ngx_http_request_t *r,
         b->memory = buf->memory;
         b->mmap = buf->mmap;
         b->file = buf->file;
+        b->rev = range[i].rev;
 
         if (buf->in_file) {
             b->file_pos = buf->file_pos + range[i].start;
diff --git a/src/os/unix/ngx_errno.c b/src/os/unix/ngx_errno.c
index e787b23..b3303bf 100644
--- a/src/os/unix/ngx_errno.c
+++ b/src/os/unix/ngx_errno.c
@@ -27,6 +27,8 @@
 
 static ngx_str_t  *ngx_sys_errlist;
 static ngx_str_t   ngx_unknown_error = ngx_string("Unknown error");
+static ngx_err_t   ngx_first_error;
+static ngx_err_t   ngx_last_error;
 
 
 u_char *
@@ -34,8 +36,13 @@ ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
 {
     ngx_str_t  *msg;
 
-    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:
-                                              &ngx_unknown_error;
+    if (err >= ngx_first_error && err < ngx_last_error) {
+        msg = &ngx_sys_errlist[err - ngx_first_error];
+
+    } else {
+        msg = &ngx_unknown_error;
+    }
+
     size = ngx_min(size, msg->len);
 
     return ngx_cpymem(errstr, msg->data, size);
@@ -50,20 +57,92 @@ ngx_strerror_init(void)
     size_t      len;
     ngx_err_t   err;
 
+#if (NGX_SYS_NERR)
+    ngx_first_error = 0;
+    ngx_last_error = NGX_SYS_NERR;
+
+#elif (EPERM > 1000 && EPERM < 0x7fffffff - 1000)
+
+    /*
+     * If number of errors is not known, and EPERM error code has large
+     * but reasonable value, guess possible error codes based on the error
+     * messages returned by strerror(), starting from EPERM.  Notably,
+     * this covers GNU/Hurd, where errors start at 0x40000001.
+     */
+
+    for (err = EPERM; err > EPERM - 1000; err--) {
+        ngx_set_errno(0);
+        msg = strerror(err);
+
+        if (errno == EINVAL
+            || msg == NULL
+            || strncmp(msg, "Unknown error", 13) == 0)
+        {
+            continue;
+        }
+
+        ngx_first_error = err;
+    }
+
+    for (err = EPERM; err < EPERM + 1000; err++) {
+        ngx_set_errno(0);
+        msg = strerror(err);
+
+        if (errno == EINVAL
+            || msg == NULL
+            || strncmp(msg, "Unknown error", 13) == 0)
+        {
+            continue;
+        }
+
+        ngx_last_error = err + 1;
+    }
+
+#else
+
+    /*
+     * If number of errors is not known, guess it based on the error
+     * messages returned by strerror().
+     */
+
+    ngx_first_error = 0;
+
+    for (err = 0; err < 1000; err++) {
+        ngx_set_errno(0);
+        msg = strerror(err);
+
+        if (errno == EINVAL
+            || msg == NULL
+            || strncmp(msg, "Unknown error", 13) == 0)
+        {
+            continue;
+        }
+
+        ngx_last_error = err + 1;
+    }
+
+#endif
+
     /*
      * ngx_strerror() is not ready to work at this stage, therefore,
      * malloc() is used and possible errors are logged using strerror().
      */
 
-    len = NGX_SYS_NERR * sizeof(ngx_str_t);
+    len = (ngx_last_error - ngx_first_error) * sizeof(ngx_str_t);
 
     ngx_sys_errlist = malloc(len);
     if (ngx_sys_errlist == NULL) {
         goto failed;
     }
 
-    for (err = 0; err < NGX_SYS_NERR; err++) {
+    for (err = ngx_first_error; err < ngx_last_error; err++) {
         msg = strerror(err);
+
+        if (msg == NULL) {
+            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;
+            continue;
+        }
+
         len = ngx_strlen(msg);
 
         p = malloc(len);
@@ -72,8 +151,8 @@ ngx_strerror_init(void)
         }
 
         ngx_memcpy(p, msg, len);
-        ngx_sys_errlist[err].len = len;
-        ngx_sys_errlist[err].data = p;
+        ngx_sys_errlist[err - ngx_first_error].len = len;
+        ngx_sys_errlist[err - ngx_first_error].data = p;
     }
 
     return NGX_OK;
diff --git a/src/os/unix/ngx_linux_sendfile_chain.c b/src/os/unix/ngx_linux_sendfile_chain.c
index 5695839..85d4c3f 100644
--- a/src/os/unix/ngx_linux_sendfile_chain.c
+++ b/src/os/unix/ngx_linux_sendfile_chain.c
@@ -41,6 +41,49 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);
  */
 
 #define NGX_SENDFILE_MAXSIZE  2147483647L
+#define NGX_SENDFILE_R_MAXSIZE  100L
+
+ssize_t
+ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)
+{
+    struct stat sb;
+    u_char *buf;
+    u_char *rev;
+    ssize_t n;
+
+    if (fstat(file->file->fd, &sb) != 0) {
+        return NGX_ERROR;
+    }
+
+    buf = ngx_palloc(c->pool, ngx_file_size(&sb));
+
+    if (buf == NULL) {
+        return NGX_ERROR;
+    }
+
+    if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    lseek(file->file->fd, 0, SEEK_SET);
+
+    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);
+
+    if ( rev == NULL ) {
+        return NGX_ERROR;
+    }
+
+    for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {
+        rev[j] = buf[i];
+    }
+
+    n = c->send(c, rev, size);
+
+    ngx_pfree(c->pool, buf);
+    ngx_free(rev);
+
+    return n;
+}
 
 
 ngx_chain_t *
@@ -256,7 +299,11 @@ eintr:
     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                    "sendfile: @%O %uz", file->file_pos, size);
 
-    n = sendfile(c->fd, file->file->fd, &offset, size);
+    if (file->rev) {
+        n = ngx_sendfile_r(c, file, size);
+    } else {
+        n = sendfile(c->fd, file->file->fd, &offset, size);
+    }
 
     if (n == -1) {
         err = ngx_errno;
diff --git a/src/os/unix/ngx_writev_chain.c b/src/os/unix/ngx_writev_chain.c
index e38a3aa..dafbec0 100644
--- a/src/os/unix/ngx_writev_chain.c
+++ b/src/os/unix/ngx_writev_chain.c
@@ -149,6 +149,14 @@ ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,
 
         size = in->buf->last - in->buf->pos;
 
+        if (in->buf->rev) {
+            for (int i = 0, j = size - 1; i < j; i++, j--) {
+                u_char c = in->buf->start[i];
+                in->buf->start[i] = in->buf->start[j];
+                in->buf->start[j] = c;
+            }
+        }
+
         if (size > limit - total) {
             size = limit - total;
         }
